#!/usr/bin/wish

## Interface for pulse fork measurements

package require Device 1.2
package require BLT
package require xBlt 3
package require SigLoad
package require Exp

# fork_pulse device
if {[llength $argv]} {
  set dev [lindex $argv 0]
}\
else {
  set dev fork0
}


##################################################

# pulse parameters:
set pars(amp) 10;     # pulse voltage
set pars(fre) 32768;  # pulse frequency
set pars(cyc) 10;     # pulse count

# oscilloscope parameters
set pars(time) 5;     # record time
set pars(tpre) 5.0;   # pretrigger percent
set pars(rate) 1e5;   # record sampling rate
set pars(sc)   1;     # oscilloscope range

# auto adjust parameters
set pars(fadj) 1;     # adjust frequency
set pars(fmin) 32000; # min value
set pars(fmax) 33000; # max value
set pars(tadj) 1;     # adjust time
set pars(tmin) 0.01;  # min value
set pars(tmax) 200;   # max value
set pars(tx)   5;     # time factor
set pars(radj) 0;     # adjust range
set pars(sadj) 1;     # adjust sampling rate

# After setting parameters use on_pars_apply to
# apply settings!

# measurement parameters
set del  10.0;   # delay between measurements,s
set meas 0;     # repeat measurements

set st   "Opening devices..."; # status line
set maxlen 1024; # number of points visible on the plot
set sigfile   "/tmp/${dev}_sig.dat"

set range_values {}; # possible values for oscilloscope range (will be autodetected later)
set need_setup 1;    # do we want to update device settings before measurements?

##################################################


# measured values
set time 0;  # system time
set amp 0;   # amplitude
set rtau 0;  # 1/relaxation time
set fre 0;   # frequency

# data for raw signal plot and fitted curves
blt::vector create sig_x
blt::vector create sig_y0
blt::vector create sig_xm
blt::vector create sig_ym1
blt::vector create sig_ym2

# data for fft plot
blt::vector create fft_x
blt::vector create fft_y

##################################################

## Create entry/checkbutton/combobox and pack it into a
## simple grid.
# w - entry widget name
# v - entry var name
# t - entry title

set label_width 20

proc mk_entry {w v t} {
  if {[regexp {^pars(.*)$} $v]} { global pars}\
  else {global $v}
  entry $w -textvariable $v -width 12
  label ${w}_l -text $t
  grid ${w}_l ${w} -sticky nw
}
## Same for checkbutton
proc mk_check {w v t} {
  if {[regexp {^pars(.*)$} $v]} { global pars}\
  else {global $v}
  checkbutton $w -text $t -variable $v
  grid $w -sticky nw -columnspan 2
}
## Same for combobox
proc mk_combo {w v t} {
  if {[regexp {^pars(.*)$} $v]} { global pars}\
  else {global $v}
  ttk::combobox $w -width 9 -textvariable $v
  label ${w}_l -text $t
  grid ${w}_l ${w} -sticky nw
}
## empty space with fixed width
proc mk_empty {w} {
  global label_width
  label ${w}_l
  set ww [font measure [${w}_l cget -font] n]
  canvas $w -height 1 -width [expr $ww*$label_width]
  grid $w -sticky nw
}

##################################################
# open device if needed and update range list
proc dev_open {} {
  global dev need_setup
  if {![itcl::is object $dev]} {
    Device $dev
    set range_values [lindex [$dev cmd get_osc_sc] 0]
    .tabs.pars.op.sc configure -values $range_values
    set need_setup 1
  }
}

# close device if needed
proc dev_close {} {
  global dev
  if {[itcl::is object $dev]} {
    itcl::delete object $dev
  }
}

##################################################
## pulse function

## version with error handling:
proc do_pulse_e {} {
  if {[catch {do_pulse}]} {
    set_state error
    return
  }
}

set bgerror {set_state error}

proc do_pulse {} {
  global dev del meas st
  global pars apars
  global time amp rtau fre
  global need_setup
  global sigfile

  # open devices if needed
  dev_open

  # setup
  if {$need_setup} {
    set st "Setting parameters..."
    $dev cmd setup $apars(fre) $apars(cyc) $apars(amp) $apars(sc)
    $dev cmd set_freq_limits $apars(fmin) $apars(fmax)
    set need_setup 0
  }
  set st "Measuring..."

  set t0 [clock milliseconds]
  if ($apars(tpre)<0)   { set apars(tpre) 0 }
  if ($apars(tpre)>100) { set apars(tpre) 100 }
  set t1 [expr {0.01*$apars(tpre)*$apars(time)}]
  set t2 [expr {$apars(time)-$t1}]
  set dt [expr {1.0/$apars(rate)}]
  set ret [lindex [$dev cmd pulse $t1 $t2 $dt $sigfile] 0]

  ## pars results
  set time [lindex $ret 0]
  set fre  [format %.6f [lindex $ret 1]]
  set rtau [format %.8f [lindex $ret 2]]
  set amp  [format %.6f [expr {1000*[lindex $ret 3]}]]

  ## push data to the time plot
  pl add_data $time [lrange $ret 1 3]

  ## load signal
  set ncols [sig_load sig $sigfile]

  global sig_x
  set min 0
  set max $sig_x(max)
  sig_xm seq $min $max [expr {($max-$min)/500}]
  sig_ym1 expr {0.5*1e-3*$amp*exp(-sig_xm*$rtau)}
  sig_ym2 expr -sig_ym1

  ## load FFT
  set ret [exec sig_filter -f fft_pow_lavr -N 10000 $sigfile]
  fft_x set {}
  fft_y set {}
  foreach l [split $ret "\n"] {
    fft_x append [lindex $l 0]
    fft_y append [lindex $l 1]
  }
  fft_y expr {sqrt(fft_y)*1e9}

  if {$fre>0} {
    ## adjust frequency if needed
    if {$apars(fadj)} {
      set apars(fre) [format %.0f $fre]
      if {$apars(fre) < $apars(fmin)} {set apars(fre) $apars(fmin)}
      if {$apars(fre) > $apars(fmax)} {set apars(fre) $apars(fmax)}
      set pars(fre) $apars(fre)
      set need_setup 1
    }
    ## adjust record time if needed
    if {$apars(tadj)} {
      set apars(time) [format %.3f [expr {$apars(tx)/$rtau}]]
      if {$apars(time) < $apars(tmin)} {set apars(time) $apars(tmin)}
      if {$apars(time) > $apars(tmax)} {set apars(time) $apars(tmax)}
      set pars(time) $apars(time)
      set need_setup 1
    }
    ## adjust oscilloscope range if needed
    if {$apars(radj)} {
      global range_values
      foreach r $range_values {
        if {1e-3*$amp < 2*0.8*$r} {
          set apars(sc) $r
          set  pars(sc) $r
          set need_setup 1
          break
        }
      }
    }
    ## adjust sampling rate if needed
    if {$apars(sadj)} {
      set min_rate [expr {2*$apars(fmax)}]
      set max_rate 20e6;
      set num 1e6
      set r [expr {$num/$apars(time)}]
      if {$r > $max_rate} {set r $max_rate}
      if {$r < $min_rate} {set r $min_rate}
      set r [format {%.2e} $r]
      set apars(rate) $r
      set  pars(rate) $r
    }
  }

  ## set up the next measurement if needed
  set t1 [clock milliseconds]
  set dt [expr int(1000*$del-$t1+$t0)]
  if {$dt<0} {set dt 0}

  # stop measurements
  if {! $meas} {
    dev_close
    set_state ready
    return
  }

  set st "Waiting for the next measurement..."
  after [expr $dt] do_pulse_e
}

##################################################
proc set_state {s} {
  global st meas
  set run_btn .meas.m.run
  set stop_btn .stop

  if {$s == "wait"} { # stop button pressed, but measurement is running
    set meas 0
    $run_btn configure -state disabled -text "..." -command ""
    set st "Waiting for devices..."
    return
  }
  if {$s == "ready"} { # ready for measurements
    set meas 0
    set st "Ready"
    $run_btn configure -state normal -text "Run" -command "set_state busy; do_pulse_e"
    return
  }
  if {$s == "error"} { # error happened but ready for measurements
    set meas 0
    set e $::errorInfo
    set n [string first "\n" $e]
    if {n>0} { set e [string range $e 0 [expr $n-1]]}
    set st "Error: $e"
    dev_close
    $run_btn configure -state normal -text "Run" -command "set_state busy; do_pulse_e"
    return
  }
  if {$s == "busy"} { # measurement started
    $run_btn configure -state normal -text "Stop" -command {set_state wait}
    set st "Measuring..."
    return
  }
  error "unknown state"
}

##################################################
## measurement frame

proc mk_meas_frame {root} {
  frame $root
  label $root.name  -text "Pulsed fork measurements: $::dev" -font {-size 12} -anchor w

  frame $root.res
  labelframe $root.res.amp -text "Amplitude, mV: "
  label $root.res.amp.val -textvariable amp  -font {-size 15} -text 0 -width 12
  pack $root.res.amp.val

  labelframe $root.res.rtau -text "1/Tau, 1/s: "
  label $root.res.rtau.val -textvariable rtau  -font {-size 15} -text 0 -width 12
  pack $root.res.rtau.val

  labelframe $root.res.fre -text "Frequency, Hz: "
  label $root.res.fre.val -textvariable fre -font {-size 15} -text 0 -width 12
  pack $root.res.fre.val
  pack $root.res.amp $root.res.rtau $root.res.fre\
    -side left -fill x -expand 1

  frame $root.m
  checkbutton $root.m.meas -text "Repeat measurements with period" -variable meas
  label       $root.m.dll -text "sec"
  entry       $root.m.del -textvariable del -width 7
  button      $root.m.run
  pack   $root.m.run $root.m.dll $root.m.del $root.m.meas -side right

  pack $root.name $root.res $root.m -fill x -expand 1
  set_state wait
}

##################################################
## signal plot frame

proc mk_splot_frame {root} {
  frame $root

  # make graph
  set pwid $root.p

  blt::graph $pwid -leftmargin 80
  pack $pwid -fill both -expand 1

  $pwid legend configure -activebackground white

  # configure standard xBLT things:
  xblt::plotmenu $pwid -showbutton 1 -buttonlabel Menu -menuoncanvas 0
  xblt::legmenu  $pwid -showseparator 0

  xblt::hielems $pwid
  xblt::crosshairs $pwid -show 1
  xblt::measure $pwid
  xblt::readout $pwid -variable v_readout -active 1
  xblt::zoomstack $pwid -axes {x y} -recttype xy
  $pwid element create res+ -xdata sig_xm -ydata sig_ym1 -symbol "" -color red -label ""
  $pwid element create res- -xdata sig_xm -ydata sig_ym2 -symbol "" -color red -label ""
  $pwid element create sig -xdata sig_x -ydata sig_y0 -symbol "" -color blue
  $pwid axis configure y -title {Amplitude, V}
}


##################################################
## fft frame

proc mk_fft_frame {root} {
  frame $root

  # make graph
  set pwid $root.p

  blt::graph $pwid -leftmargin 80
  pack $pwid -fill both -expand 1

  $pwid legend configure -activebackground white

  # configure standard xBLT things:
  xblt::plotmenu $pwid -showbutton 1 -buttonlabel Menu -menuoncanvas 0
  xblt::legmenu  $pwid -showseparator 0

  xblt::hielems $pwid
  xblt::crosshairs $pwid -show 1
  xblt::measure $pwid
  xblt::readout $pwid -variable v_readout -active 1
  xblt::zoomstack $pwid -axes {x y} -recttype xy
  $pwid element create fft -xdata fft_x  -ydata fft_y -symbol "" -color blue
  $pwid axis configure y -title {Spectral density, nV/sqrt(Hz)} -logscale 1
  $pwid axis configure x -title {Frequency, Hz} -logscale 1
}

##################################################
## time plot frame

proc mk_tplot_frame {root} {
  frame $root
  set graph $root.p
  set swid $root.sb

  TimePlot pl $graph\
    -ncols 3\
    -maxt 3600\
    -names {amp width freq}\
    -plots_x {time freq}\
    -plots_y {{}   width}\
    -use_comm 0
  pack $graph -fill both -expand 1
}


##################################################
## parameters frame

proc on_pars_reset {} {
  global pars apars
  array set pars [array get apars]
}
proc on_pars_apply {} {
  global pars apars need_setup
  array set apars [array get pars]
  set need_setup 1
}

proc mk_pars_frame {root} {
  frame $root

  #######################
  ## generator parameters
  set w $root.pp
  labelframe $w -text {generator parameters}\
                -font {-weight bold} -padx 5 -pady 5
  foreach {v title} {
        fre "Frequency, Hz"
        amp "Amplitude, V"
        cyc "Cycles"
        } {
    mk_entry $w.${v} pars($v) $title
  }
  mk_empty $w.e
  grid $w -sticky ew -padx 5 -row 1 -column 1 -sticky ns


  #######################
  ## osc parameters
  set w $root.op
  labelframe $w -text {oscilloscope parameters}\
                -font {-weight bold} -padx 5 -pady 5
  foreach {v title} {
        time "Record time, s"
        tpre "Pretrigger, %"
        rate "Sampling rate, Hz"
        } {
    mk_entry $w.${v} pars($v) $title
  }
  mk_empty $w.e
  mk_combo $w.sc pars(sc) "Range, V"
  grid $w -sticky ew -padx 5 -row 2 -column 1 -sticky ns


  #######################
  ## auto
  set w $root.ap
  labelframe $w -text {auto adjustments}\
                -font {-weight bold} -padx 5 -pady 5

  mk_check $w.fadj pars(fadj) "Adjust frequency"
  foreach {v title} {
        fmin "min value, Hz"
        fmax "max value, Hz"
        } {
    mk_entry $w.${v} pars($v) $title
  }
  mk_check $w.tadj pars(tadj) "Adjust record time"
  foreach {v title} {
        tmin "min value, s"
        tmax "max value, s"
        tx   "factor"
        } {
    mk_entry $w.${v} pars($v) $title
  }
  mk_check $w.sadj pars(sadj) "Adjust sampling rate"
  mk_check $w.radj pars(radj) "Adjust oscilloscope range"
  mk_empty $w.e
  grid $w -sticky ew -padx 5  -row 1 -column 2 -rowspan 2 -sticky ns

  frame $root.btn
  button $root.btn.reset -text "Reset"  -command on_pars_reset
  button $root.btn.apply -text "Apply"  -command on_pars_apply
  grid $root.btn.reset $root.btn.apply  -padx 20 -pady 5
  grid $root.btn -row 3 -column 2 -sticky n

}




##################################################
# rest of the interface

mk_meas_frame {.meas}
pack .meas -fill x -expand 1

blt::tabset .tabs -side top

mk_splot_frame {.tabs.splot}
mk_fft_frame   {.tabs.fft}
mk_tplot_frame {.tabs.tplot}
mk_pars_frame  {.tabs.pars}

## tabset
.tabs insert end splot -window .tabs.splot\
   -anchor n -text "Signal plot" -fill both
.tabs insert end fft -window .tabs.fft\
   -anchor n -text "FFT plot" -fill both
.tabs insert end tplot -window .tabs.tplot\
   -anchor n -text "Time plot" -fill both
.tabs insert end pars -window .tabs.pars\
   -anchor n -text "Parameters" -fill both

pack .tabs -fill both -expand 1

## status line on the bottom
label .st -textvariable st
button .exit -text "Exit" -command exit
pack .exit -side left -padx 10
pack .st   -side left -padx 10 -fill x

##################################################

update
after idle {
  on_pars_apply

  # Open device,
  # fill ocilloscope range combobox with values
  if {[catch {dev_open}]} {
    set_state error
  }\
  else {
    dev_close
    set_state ready
  }
}


