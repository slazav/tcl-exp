#!/usr/bin/wish

## Interface for pulse fork measurements

package require Device 1.2
package require BLT
package require xBlt 3
package require SigLoad

# fork_pulse device
set dev fork0


##################################################

# pulse parameters:
set pars(amp) 10;     # pulse voltage
set pars(fre) 32768;  # pulse frequency
set pars(cyc) 10;     # pulse count

# oscilloscope parameters
set pars(time) 5;     # record time
set pars(tpre) 0.01;  # pretrigger time
set pars(dt) 1e-5;    # record sampling rate
set pars(sc)  0.5;    # oscilloscope range

# auto adjust parameters
set pars(fadj) 1;     # adjust frequency
set pars(fmin) 32000; # min value
set pars(fmax) 33000; # max value
set pars(tadj) 1;     # adjust time
set pars(tmin) 0.1;   # min value
set pars(tmax) 200;   # max value
set pars(tx)   5;     # time factor
set pars(radj) 1;     # adjust range

# After setting parameters use on_pars_apply to
# apply settings!

# measurement parameters
set del  1.0;   # delay between measurements,s
set meas 0;     # repeat measurements
set st   "Opening devices..."; # status line
set maxlen 1024; # number of points visible on the plot
set sigfile   "/tmp/${dev}_sig.dat"

set range_values {}; # possible values for oscilloscope range (will be autodetected later)
set need_setup 1;    # do we want to update device settings before measurements?

##################################################


# measured values
set time 0;  # system time
set amp 0;   # amplitude
set rtau 0;  # 1/relaxation time
set fre 0;   # frequency

# data for time plot
blt::vector create tvec
blt::vector create avec
blt::vector create wvec
blt::vector create fvec

# data for raw signal plot and fitted curves
blt::vector create sig_x
blt::vector create sig_y0
blt::vector create sig_xm
blt::vector create sig_ym1
blt::vector create sig_ym2

# data for fft plot
blt::vector create fft_x
blt::vector create fft_y

##################################################

## Create entry/checkbutton/combobox and pack it into a
## simple grid.
# w - entry widget name
# v - entry var name
# t - entry title

set label_width 20

proc mk_entry {w v t} {
  if {[regexp {^pars(.*)$} $v]} { global pars}\
  else {global $v}
  entry $w -textvariable $v -width 12
  label ${w}_l -text $t
  grid ${w}_l ${w} -sticky nw
}
## Same for checkbutton
proc mk_check {w v t} {
  if {[regexp {^pars(.*)$} $v]} { global pars}\
  else {global $v}
  checkbutton $w -text $t -variable $v
  grid $w -sticky nw -columnspan 2
}
## Same for combobox
proc mk_combo {w v t} {
  if {[regexp {^pars(.*)$} $v]} { global pars}\
  else {global $v}
  ttk::combobox $w -width 9 -textvariable $v
  label ${w}_l -text $t
  grid ${w}_l ${w} -sticky nw
}
## empty space with fixed width
proc mk_empty {w} {
  global label_width
  label ${w}_l
  set ww [font measure [${w}_l cget -font] n]
  canvas $w -height 1 -width [expr $ww*$label_width]
  grid $w -sticky nw
}



##################################################
## pulse function

proc do_pulse {} {
  global dev del meas st
  global pars apars
  global time amp rtau fre
  global need_setup
  global sigfile


  if {$need_setup} {
    set st "Setting parameters..."
    $dev cmd setup $apars(fre) $apars(cyc) $apars(amp) $apars(sc)
    $dev cmd set_freq_limits $apars(fmin) $apars(fmax)
    set need_setup 0
  }
  set st "Measuring..."

  set t0 [clock milliseconds]
  set ret [lindex [$dev cmd pulse $apars(tpre) $apars(time) $apars(dt) $sigfile] 0]

  ## pars results
  set time [lindex $ret 0]
  set fre  [format %.6f [lindex $ret 1]]
  set rtau [format %.6f [lindex $ret 2]]
  set amp  [format %.6f [expr {1000*[lindex $ret 3]}]]

  global maxlen
  tvec append $time
  fvec append $fre
  wvec append $rtau
  avec append $amp
  # remove old values:
  if {[tvec length] > [expr $maxlen+100]} {
    tvec delete 0:99
    fvec delete 0:99
    wvec delete 0:99
    avec delete 0:99
  }

  ## load signal
  set ncols [sig_load sig $sigfile]

  global sig_x
  set min $sig_x(min)
  set max $sig_x(max)
  sig_xm seq $min $max [expr {($max-$min)/500}]
  sig_ym1 expr {0.5*1e-3*$amp*exp(-sig_xm*$rtau)}
  sig_ym2 expr -sig_ym1


  ## load FFT
  set ret [exec sig_filter -f fft_pow_lavr -N 10000 $sigfile]
  fft_x set {}
  fft_y set {}
  foreach l [split $ret "\n"] {
    fft_x append [lindex $l 0]
    fft_y append [lindex $l 1]
  }
  fft_y expr {sqrt(fft_y)*1e9}


  ## adjust frequency if needed
  if {$apars(fadj)} {
    set apars(fre) [format %.0f $fre]
    if {$apars(fre) < $apars(fmin)} {set apars(fre) $apars(fmin)}
    if {$apars(fre) > $apars(fmax)} {set apars(fre) $apars(fmax)}
    set pars(fre) $apars(fre)
    set need_setup 1
  }
  ## adjust record time if needed
  if {$apars(tadj)} {
    set apars(time) [format %.3f [expr {$apars(tx)/$rtau}]]
    if {$apars(time) < $apars(tmin)} {set apars(time) $apars(tmin)}
    if {$apars(time) > $apars(tmax)} {set apars(time) $apars(tmax)}
    set pars(time) $apars(time)
    set need_setup 1
  }
  ## adjust oscilloscope range if needed
  if {$apars(radj)} {
    global range_values
    foreach r $range_values {
      if {1e-3*$amp < 2*0.8*$r} {
        set apars(sc) $r
        set  pars(sc) $r
        set need_setup 1
        break
      }
    }
  }

  ## set up the next measurement if needed
  set t1 [clock milliseconds]
  set dt [expr int(1000*$del-$t1+$t0)]
  if {$dt<0} {set dt 0}

  if {! $meas} {
    set_state ready
    return
  }

  set st "Waiting for the next measurement..."
  after [expr $dt] do_pulse
}


proc set_state {s} {
  global st meas
  set run_btn .meas.m.run
  set stop_btn .stop

  if {$s == "wait"} {
    set meas 0
    $run_btn configure -state disabled -text "Run" -command ""
    set st "Waiting for devices..."
    return
  }
  if {$s == "ready"} {
    set meas 0
    $run_btn configure -state normal -text "Run" -command "set_state busy; do_pulse"
    set st "Ready"
    return
  }
  if {$s == "busy"} {
    set meas 1
    $run_btn configure -state normal -text "Stop" -command {set_state wait}
    set st "Measuring..."
    return
  }
  error "unknown state"
}

##################################################
## measurement frame

proc mk_meas_frame {root} {
  frame $root

  frame $root.res

  labelframe $root.res.amp -text "Amplitude, mV: "
  label $root.res.amp.val -textvariable amp  -font {-size 15} -text 0 -width 12
  pack $root.res.amp.val

  labelframe $root.res.rtau -text "1/Tau, 1/s: "
  label $root.res.rtau.val -textvariable rtau  -font {-size 15} -text 0 -width 12
  pack $root.res.rtau.val

  labelframe $root.res.fre -text "Frequency, Hz: "
  label $root.res.fre.val -textvariable fre -font {-size 15} -text 0 -width 12
  pack $root.res.fre.val
  pack $root.res.amp $root.res.rtau $root.res.fre\
    -side left -fill x -expand 1

  frame $root.m
  label       $root.m.dll -text "Measurement period, s:"
  entry       $root.m.del -textvariable del -width 7
  button      $root.m.run
  pack  $root.m.run $root.m.del $root.m.dll -side right

  pack $root.res $root.m -fill x -expand 1
  set_state wait
}

##################################################
## signal plot frame

proc mk_splot_frame {root} {
  frame $root

  # make graph
  set pwid $root.p

  blt::graph $pwid -leftmargin 80
  pack $pwid -fill both -expand 1

  $pwid legend configure -activebackground white

  # configure standard xBLT things:
  xblt::plotmenu $pwid -showbutton 1 -buttonlabel Menu -menuoncanvas 0
  xblt::legmenu  $pwid -showseparator 0

  xblt::hielems $pwid
  xblt::crosshairs $pwid -show 1
  xblt::measure $pwid
  xblt::readout $pwid -variable v_readout -active 1
  xblt::zoomstack $pwid -axes {x y} -recttype xy
  $pwid element create res+ -xdata sig_xm -ydata sig_ym1 -symbol "" -color red -label ""
  $pwid element create res- -xdata sig_xm -ydata sig_ym2 -symbol "" -color red -label ""
  $pwid element create sig -xdata sig_x -ydata sig_y0 -symbol "" -color blue
  $pwid axis configure y -title {Amplitude, V}
}


##################################################
## fft frame

proc mk_fft_frame {root} {
  frame $root

  # make graph
  set pwid $root.p

  blt::graph $pwid -leftmargin 80
  pack $pwid -fill both -expand 1

  $pwid legend configure -activebackground white

  # configure standard xBLT things:
  xblt::plotmenu $pwid -showbutton 1 -buttonlabel Menu -menuoncanvas 0
  xblt::legmenu  $pwid -showseparator 0

  xblt::hielems $pwid
  xblt::crosshairs $pwid -show 1
  xblt::measure $pwid
  xblt::readout $pwid -variable v_readout -active 1
  xblt::zoomstack $pwid -axes {x y} -recttype xy
  $pwid element create fft     -xdata fft_x  -ydata fft_y -symbol "" -color blue
  $pwid axis configure y -title {Spectral density, nV/sqrt(Hz)} -logscale 1
}

##################################################
## time plot frame

proc mk_tplot_frame {root} {
  frame $root
  set graph $root.p
  set swid $root.sb

  blt::graph $graph -leftmargin 100
  pack $graph -side top -expand yes -fill both
  $graph legend configure -activebackground white

  scrollbar $swid -orient horizontal
  pack $swid -fill x

  button $root.clear_btn -text "Clear" -command "on_tplot_clear $graph"
  pack $root.clear_btn -side right

  # configure standard xBLT things:
  xblt::plotmenu   $graph -showbutton 1 -buttonlabel Menu -menuoncanvas 0
  xblt::legmenu    $graph
  xblt::hielems    $graph
  xblt::crosshairs $graph -variable v_crosshairs
  xblt::measure    $graph
  xblt::readout    $graph -variable v_readout -active 1;
  xblt::zoomstack  $graph -scrollbutton 2 -axes x -recttype x
  xblt::elemop     $graph
  xblt::scroll     $graph $swid -timefmt 1

  $graph axis create fre  -title Frequency -titlecolor black
  $graph axis create amp  -title Amplitude -titlecolor black
  $graph axis create rtau -title Width     -titlecolor black

  $graph element create fre -xdata tvec -ydata fvec -mapy fre\
    -symbol circle -pixels 1.5 -linewidth 1 -color blue
  $graph element create rtau -xdata tvec -ydata wvec -mapy rtau\
    -symbol circle -pixels 1.5 -linewidth 1 -color green
  $graph element create amp  -xdata tvec -ydata avec -mapy amp\
    -symbol circle -pixels 1.5 -linewidth 1 -color red

  $graph element bind fre  <Enter> [list $graph yaxis use fre]
  $graph element bind rtau <Enter> [list $graph yaxis use rtau]
  $graph element bind amp  <Enter> [list $graph yaxis use amp]

#  tvec notify callback "$graph axis configure x -stepsize 0 -subdivisions 0"
}

proc on_tplot_clear {graph} {
  tvec clear
  fvec clear
  wvec clear
  avec clear
}

##################################################
## parameters frame

proc on_pars_reset {} {
  global pars apars
  array set pars [array get apars]
}
proc on_pars_apply {} {
  global pars apars need_setup
  array set apars [array get pars]
  set need_setup 1
}

proc mk_pars_frame {root} {
  frame $root
  set w $root.pp
  labelframe $w -text {generator parameters}\
                -font {-weight bold} -padx 5 -pady 5
  foreach {v title} {
        fre "Frequency, Hz"
        amp "Amplitude, V"
        cyc "Cycles"
        } {
    mk_entry $w.${v} pars($v) $title
  }
  mk_empty $w.e
  grid $w -sticky ew -padx 5 -row 1 -column 1 -sticky ns


  set w $root.op
  labelframe $w -text {oscilloscope parameters}\
                -font {-weight bold} -padx 5 -pady 5
  foreach {v title} {
        tpre "Pretrigger time, s"
        time "Record time, s"
        dt   "Sampling rate, s"
        } {
    mk_entry $w.${v} pars($v) $title
  }
  mk_empty $w.e
  mk_combo $w.sc pars(sc) "Range, V"
  grid $w -sticky ew -padx 5 -row 2 -column 1 -sticky ns


  set w $root.ap
  labelframe $w -text {auto adjustments}\
                -font {-weight bold} -padx 5 -pady 5

  mk_check $w.fadj pars(fadj) "Adjust frequency"
  foreach {v title} {
        fmin "min value, Hz"
        fmax "max value, Hz"
        } {
    mk_entry $w.${v} pars($v) $title
  }
  mk_check $w.tadj pars(tadj) "Adjust record time"
  foreach {v title} {
        tmin "min value, s"
        tmax "max value, s"
        tx   "factor"
        } {
    mk_entry $w.${v} pars($v) $title
  }
  mk_check $w.radj pars(radj) "Adjust oscilloscope range"
  mk_empty $w.e
  grid $w -sticky ew -padx 5  -row 1 -column 2 -rowspan 2 -sticky ns

  frame $root.btn
  button $root.btn.reset -text "Reset"  -command on_pars_reset
  button $root.btn.apply -text "Apply"  -command on_pars_apply
  grid $root.btn.reset $root.btn.apply  -padx 20 -pady 5
  grid $root.btn -row 3 -column 2 -sticky n

}




##################################################
# rest of the interface

mk_meas_frame {.meas}
pack .meas -fill x -expand 1

blt::tabset .tabs -side top

mk_splot_frame {.tabs.splot}
mk_fft_frame   {.tabs.fft}
mk_tplot_frame {.tabs.tplot}
mk_pars_frame  {.tabs.pars}

## tabset
.tabs insert end splot -window .tabs.splot\
   -anchor n -text "Signal plot" -fill both
.tabs insert end fft -window .tabs.fft\
   -anchor n -text "FFT plot" -fill both
.tabs insert end tplot -window .tabs.tplot\
   -anchor n -text "Time plot" -fill both
.tabs insert end pars -window .tabs.pars\
   -anchor n -text "Parameters" -fill both

pack .tabs -fill both -expand 1

## status line on the bottom
label .st -textvariable st
button .exit -text "Exit" -command exit
pack .exit -side left -padx 10
pack .st   -side left -padx 10 -fill x

##################################################


# Open and set up the device
Device $dev

# fill scilloscope range combobox with values
set range_values [lindex [$dev cmd get_osc_sc] 0]
.tabs.pars.op.sc configure -values $range_values

# set some parameters, unlock run buttons
on_pars_apply
set_state ready


