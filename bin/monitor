#!/usr/bin/wish

## A monitoring script (pcell, leakdetector etc.)

package require DeviceRole
package require xBlt
package require Exp

set Device::sync 1

### parameters

set default_pars [list \
  name           {Default}      {program title}\
  gauge_dev      {mult1:DCV}    {gauge device}\
  db_dev         db_exp         {db device}\
  db             {}             {database name}\
  units          {}             {value units}\
  dt             1              {default time step}\
  cal            {}             {calibration function}\
  plot_ncols   1    {number of columns in the plot}\
  plot_maxt    600  {max time span in the plot}\
  plot_maxn    0    {max number of points in the plot}\
  plot_names   {v}     {column names}\
  plot_titles  {}      {column titles}\
  plot_colors  {}      {column colors}\
  plot_hides   {}      {column hides}\
  plot_logs    {}      {column log scales}\
  plot_symbols {}      {symbols}\
  plot_ssizes  {}      {symbol sizes}\
  plot_fmts    {}      {column format settings}\
  plot_comm    1       {use comment in the plot}\
  plot_marker  0       {use marker in the plot}\
  plots_x   {time}     {x data for plots}\
  plots_y   {{}}       {y data for plots}\
  plots_zst {}         {zoom styles for plots}\
]

if {[llength $argv]>0 } {
  read_conf [lindex $argv 0] pars $default_pars
}\
else {
  foreach {name def title} $default_pars { set pars($name) $def }
}

wm title . "monitor: $pars(name)"
tk appname "monitor: $pars(name)"

##########################################################

set val {};  # measured value
set dev {};  # low-level device
set state 0; # program state
set rh {};   # main loop handler


##########################################################
proc do_onoff {state} {
  if {$state == 0} { sweeper turn_off }\
  else { sweeper turn_on }
  enable $state
  set ::state $state
}

##########################################################
## a few things for the interface
set control_widgets {}; # list of widgets to be enabled/disabled

proc enable {v} {
  foreach w $::control_widgets {
    foreach ch [winfo children $w] {
      $ch configure -state [expr {$v?{normal}:{disabled}}]
    }
  }
}

proc do_onoff {state} {
  global dev
  if {$state == 0} {
    if {$dev!={}} {
      itcl::delete object $dev
      set dev {}
    }
  }\
  else {
    if {$::pars(gauge_dev)!={}} {
      set dev [DeviceRole $::pars(gauge_dev) gauge]
    }
  }
  enable $state
  set ::state $state
  measure
}

##########################################################
proc measure {} {
  global dev pars val rh
  after cancel $rh
  if {$dev=={}} return
  set val0 [$dev get]
  set time [expr [clock millisecond]/1000.0]

  # apply calibration if needed
  if {$pars(cal)!={}} {
    proc pcal {val} {return [expr "$::pars(cal)"]}
    set val [pcal $val0]
  }\
  else {
    set val $val0
  }

#  puts ">> $time $val $val0"

  time_plot add_data [list $time $val $val0]

  # put values into db
  if {$pars(db_dev)!={} && $pars(db)!={}} {
    Device $pars(db_dev)
    if {$pars(cal)!={}} {
      $pars(db_dev) cmd put $pars(db) $time $val $val0 }\
    else {
      $pars(db_dev) cmd put $pars(db) $time $val0 }
    itcl::delete object $pars(db_dev)
  }

  if {$pars(dt)>0} {
    set dt [expr {int($pars(dt)*1000.0)}]
    set rh [after $dt measure]
  }
}

##########################################################
## make interface

proc make_control {root} {
  global pars
  labelframe $root -padx 5 -pady 5

  frame $root.m;  # measure frame
  label $root.m.val -font {-size 14 -weight bold} -textvariable ::val
  label $root.m.unt -text " $pars(units) " -font {-size 12}
  grid $root.m.val $root.m.unt -sticky w
  pack $root.m -fill x
  set ::control_widgets $root.m

  frame $root.dt;  # go frame
  label $root.dt.lbl -text "time step: " -padx 2 -pady 2
  entry $root.dt.val  -width 10 -textvariable ::pars(dt)
  label $root.dt.unt -text " s"

  grid $root.dt.lbl $root.dt.val $root.dt.lbl -sticky w -padx 3
  pack $root.dt -fill x
  lappend ::control_widgets $root.dt

  frame $root.b;  # button frame
  checkbutton $root.b.oo -text "on/off" -variable ::state -command {do_onoff $::state}
  grid $root.b.oo -sticky w
  pack $root.b -fill x
  enable 0
}

# program title
frame .n
label .n.name   -text "$pars(name)" -font {-size 20}
pack .n.name -side left -padx 10
pack .n -anchor w

make_control .f
pack .f -anchor w -fill x -expand 0

######################
# make graph
TimePlot time_plot .tplot\
   -ncols    $pars(plot_ncols)\
   -maxt     $pars(plot_maxt)\
   -colors   $pars(plot_colors)\
   -titles   $pars(plot_titles)\
   -names    $pars(plot_names)\
   -hides    $pars(plot_hides)\
   -logs     $pars(plot_logs)\
   -symbols  $pars(plot_symbols)\
   -ssizes   $pars(plot_ssizes)\
   -fmts     $pars(plot_fmts)\
   -plots_x  $pars(plots_x)\
   -plots_y  $pars(plots_y)\
   -zstyles  $pars(plots_zst)\
   -use_comm   $pars(plot_comm)\
   -use_marker $pars(plot_marker)

pack .tplot -fill both -expand 1


##########################################################

measure

