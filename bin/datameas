#!/usr/bin/wish

package require DeviceRole
package require Exp;  # timeplot, monitor

##########################################################################
## read parameters from configuration file

set default_pars {
  name         {Default}  {program name}
  period       {1.0}      {measurement period}
  onoff        0          {initial state of main switch}
  save         0          {initial state of save switch}
  gauge_dev    {TEST}     {gauge device}
  db_dev       {}         {database device}
  db_name      {}         {database name (one name to put all in one or list of names to put each channel separately)}
  tpos         0.5        {timestamp position: 0-beginning of measurement, 1-end of measuremen}
  tconv        0          {ms, time shift between samples in 1 step}

  data_title   {Data:}    {data title in the interface}
  time_title   {Time:}    {time title in the interface}
  tfmt         {%H:%M:%S} {time format string for the interface}
  dfmt         {%.3e}     {data format string for the interface}
  data_convs   {}         {data conversion for each data column - list of expr\
                           statements with $x variable (like {{$x*2} {sin($x)}} etc.) }
  plot_ncols   1          {number of columns in the plot}
  plot_maxt    600        {max time span in the plot}
  plot_maxn    0          {max number of points in the plot}
  plot_names   {data}     {column names}
  plot_titles  {}         {column titles}
  plot_colors  {}         {column colors}
  plot_hides   {}         {column hides}
  plot_logs    {}         {column log scales}
  plot_symbols {}         {symbols}
  plot_ssizes  {}         {symbol sizes}
  plot_fmts    {}         {column format settings}
  plot_comm    0          {use comment in the plot}
  plot_marker  0          {use marker in the plot}
  plots_x      {time}     {x data for plots}
  plots_y      {{}}       {y data for plots}
  plots_zst    {}         {zoom styles for plots}
}

if {[llength $argv]>0 } {
  read_conf [lindex $argv 0] pars $default_pars
}\
else {
  foreach {name def title} $default_pars { set pars($name) $def }
}

tk appname "datameas: $pars(name)"

##########################################################################
##########################################################################
set D0  {};  # current data
set Df  {};  # formatted data (see -dfmt option)
set T0  {};  # current time (seconds)
set Tf  {};  # current formatted time (-tfmt option)
set dev {};  # gauge device handler

##########################################################################
##########################################################################
## functions for the monitor class

# Open devices
proc func_start {} {
  global pars dev
  if {$pars(gauge_dev)!={}} {set dev [DeviceRole $pars(gauge_dev) gauge]}
  if {$pars(db_dev)!={}} { Device $pars(db_dev) }
}

# Close devices
proc func_stop {} {
  global pars dev
  if {$pars(gauge_dev)!={}} { DeviceRoleDelete $dev }
  if {$pars(db_dev)!={}} { DeviceDelete $pars(db_dev) }
}

# Do a single measurement, return data
proc func_meas {} {
  global pars dev D0 Df T0 Tf
  if {$dev=={}} return
  set t1 [clock microseconds]
  set D0 [$dev get]
  set t2 [clock microseconds]

  # convert data with data_convs
  set i 0
  foreach x $D0 conv $pars(data_convs) {
    if {$conv == {}} {continue}
    lset D0 $i [expr $conv]
    incr i
  }

  # calculate timestamp
  set T0 [expr {($t1 + ($t2-$t1)*$pars(tpos))/1e6}]

  # format data and time for the interface
  if {$pars(dfmt) != {}} { set Df [format $pars(dfmt) {*}$D0] }\
  else {set Df $D0}
  set Tf [clock format [expr int($T0)] -format $pars(tfmt)]

  # append data to timeplot
  time_plot add_data "$T0 $D0"

  # put data to database
  if {$pars(db_dev)!={} && $pars(save)} {
    if { [llength $pars(db_name)]==1 } {
      $pars(db_dev) cmd put $pars(db_name) $T0 $D0
      $pars(db_dev) cmd sync
    } else {
      set i 0
      foreach db $pars(db_name) d $D0 {
        $pars(db_dev) cmd put $db [expr $T0+$i*$pars(tconv)] $d
        $pars(db_dev) cmd sync
        incr i
      }
    }
  }
}

# Build GUI frame in <root> (user-supplied function)
proc func_mkint {w} {
  global pars
  frame $w.data
  label $w.data.tl -text $pars(time_title)
  label $w.data.vl -text $pars(data_title)
  label $w.data.t -fg darkgreen -font {-size 12} -textvariable Tf
  label $w.data.v -fg darkgreen -font {-size 12} -textvariable Df
  checkbutton $w.data.save -text "save to DB" -selectcolor "red" -bd 1 -relief raised\
    -variable pars(save) -command "set_checkbox_color $w.data.save"
  pack $w.data.tl $w.data.t $w.data.vl $w.data.v -side left
  if {$pars(db_dev) != {}} {pack $w.data.save -side right}

  set Tf [clock format [clock seconds] -format $pars(tfmt)]

  TimePlot time_plot $w.tplot\
   -ncols      $pars(plot_ncols)\
   -maxt       $pars(plot_maxt)\
   -colors     $pars(plot_colors)\
   -titles     $pars(plot_titles)\
   -names      $pars(plot_names)\
   -hides      $pars(plot_hides)\
   -logs       $pars(plot_logs)\
   -symbols    $pars(plot_symbols)\
   -ssizes     $pars(plot_ssizes)\
   -fmts       $pars(plot_fmts)\
   -plots_x    $pars(plots_x)\
   -plots_y    $pars(plots_y)\
   -zstyles    $pars(plots_zst)\
   -use_comm   $pars(plot_comm)\
   -use_marker $pars(plot_marker)

  grid $w.data -sticky we
  grid $w.tplot -sticky wens
  grid columnconfigure $w 0 -weight 1
  grid rowconfigure    $w 1 -weight 1
}

#########################
proc set_checkbox_color {cb} {
  global pars
  set v [set [$cb cget -variable]]
  $cb configure -selectcolor [expr $v?"green":"red"]
}

##########################################################################
##########################################################################
## create the monitor class
Monitor m .m -name $pars(name) -period $pars(period) -onoff $pars(onoff)\
  -func_start func_start -func_stop func_stop\
  -func_meas func_meas -func_mkint func_mkint
pack .m -expand 1 -fill both
wm protocol . WM_DELETE_WINDOW { m do_exit }
