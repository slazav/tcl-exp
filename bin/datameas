#!/usr/bin/wish

package require DeviceRole
package require Exp;  # timeplot, monitor

##########################################################################
## read parameters from configuration file

set default_pars {
  name         {Default}  {program name}
  period       {1.0}      {measurement period}
  onoff        0          {initial state of main switch}
  save         0          {initial state of save switch}
  savebtn      1          {draw the save switch}
  gauge_dev    {TEST}     {gauge device}
  db_dev       {}         {database device}
  db_name      {}         {database name (one name to put all in one or list of names to put each channel separately)}
  tpos         0.5        {timestamp position: 0-beginning of measurement, 1-end of measuremen}
  tconv        0          {ms, time shift between samples in 1 step}

  time_title   {Time:}    {time title in the interface}
  print_values labels_top {labels_top | frames_top | none}
  tfmt         {%H:%M:%S} {time format string for the interface}
  dfmt         {%.3e}     {data format string for the interface}
  data_convs   {}         {data conversion for each data column - list of expr\
                           statements with $x variable (like {{$x*2} {sin($x)}} etc.) }
  data_curves  {}         {data calibration curves (see TempCurve description).\
                           If both data_convs and data_curves are non-empty for\
                           a given column, then data_convs is applied first.}
  data_add     {replace}  {What to do with data from data_convs/data_curves:\
                           replace - replace existing data, insert - insert after\
                           the column, append - append at the end of data list}
  plot_ncols   1          {number of columns in the plot}
  plot_maxt    600        {max time span in the plot}
  plot_maxn    0          {max number of points in the plot}
  plot_names   {data}     {column names}
  plot_titles  {}         {column titles}
  plot_colors  {}         {column colors}
  plot_hides   {}         {column hides}
  plot_logs    {}         {column log scales}
  plot_symbols {}         {symbols}
  plot_ssizes  {}         {symbol sizes}
  plot_fmts    {}         {column format settings}
  plot_comm    0          {use comment in the plot}
  plot_marker  0          {use marker in the plot}
  plots_x      {time}     {x data for plots}
  plots_y      {{}}       {y data for plots}
  plots_zst    {}         {zoom styles for plots}
}

if {[llength $argv]>0 } {
  read_conf [lindex $argv 0] pars $default_pars
}\
else {
  foreach {name def title} $default_pars { set pars($name) $def }
}

tk appname "datameas: $pars(name)"

##########################################################################
##########################################################################
set T0  {};      # current time (seconds)
set D0  {};      # current data (list)
array unset Df;  # formatted data (see -dfmt option)
set Tf  {};  # current formatted time (-tfmt option)
set dev {};  # gauge device handler
set curves {}; # calibration curves

foreach c $pars(data_curves) {
  if {$c!={}} {lappend curves [TempCurve #auto]}\
  else {lappend curves {}}
}

##########################################################################
##########################################################################
## functions for the monitor class

# Open devices
proc func_start {} {
  global pars dev curves
  if {$pars(gauge_dev)!={}} {set dev [DeviceRole $pars(gauge_dev) gauge]}
  if {$pars(db_dev)!={}} { Device $pars(db_dev) }

  # re-read calibration curves
  foreach c $curves f $pars(data_curves) {
    if {$c!={}} { $c read_file $f } 
  }
}

# Close devices
proc func_stop {} {
  global pars dev
  if {$pars(gauge_dev)!={}} { DeviceRoleDelete $dev }
  if {$pars(db_dev)!={}} { DeviceDelete $pars(db_dev) }
}

# Do a single measurement, return data
proc func_meas {} {
  global pars dev D0 Df T0 Tf curves
  if {$dev=={}} return
  set t1 [clock microseconds]
  set D0 [$dev get]
  set t2 [clock microseconds]

  # convert data with data_convs and data_curves
  set converted {}
  set convertede {}
  foreach x $D0 conv $pars(data_convs) curve $curves {
    set v $x
    set cnv 0
    if {$conv  != {}} {set v [expr $conv]; set cnv 1}
    if {$curve != {}} {set v [$curve calc $v]; set cnv 1}

    if {$cnv} {
      switch -exact -- $pars(data_add) {
        {replace} {lappend converted $v}
        {insert}  {lappend converted $x; lappend converted $v}
        {append}  {lappend converted $x; lappend convertede $v}
        default {error "unknown data_add setting: $pars(data_add). replace, insert, or append expected"}
      }
    }\
    else {
      lappend converted $x
    }
  }
  set D0 [concat $converted $convertede]

  # calculate timestamp
  set T0 [expr {($t1 + ($t2-$t1)*$pars(tpos))/1e6}]

  # format data and time for the interface
  set Tf [clock format [expr int($T0)] -format $pars(tfmt)]
  set i 0
  foreach name $pars(plot_names) fmt $pars(dfmt) val $D0 {
    if {$fmt != {}} {
      set Df($name) [format $fmt $val]
    } else {
      set Df($name) $val
    }
  }

  # append data to timeplot
  time_plot add_data "$T0 $D0"

  # put data to database
  if {$pars(db_dev)!={} && $pars(save)} {
    if { [llength $pars(db_name)]==1 } {
      $pars(db_dev) cmd put $pars(db_name) $T0 $D0
      $pars(db_dev) cmd sync
    } else {
      set i 0
      foreach db $pars(db_name) d $D0 {
        $pars(db_dev) cmd put $db [expr $T0+$i*$pars(tconv)] $d
        $pars(db_dev) cmd sync
        incr i
      }
    }
  }
}

# Build GUI frame in <root> (user-supplied function)
proc func_mkint {w} {
  global pars
  frame $w.data

  set top 1
  switch -exact -- $pars(print_values) {
    labels_top {
      label $w.data.tl -text $pars(time_title)
      label $w.data.t -fg darkgreen -font {-size 12} -textvariable Tf -width 8
      pack $w.data.tl $w.data.t -side left
      foreach n $pars(plot_names) {
        label $w.data.l$n -text "$n:"
        label $w.data.v$n -fg darkgreen -font {-size 12} -textvariable Df($n)
        pack $w.data.l$n $w.data.v$n -side left
      }
    }
    labels_left {
      labelframe $w.data.tab
      label $w.data.tab.lt -text $pars(time_title)
      label $w.data.tab.vt -fg darkgreen -font {-size 12} -textvariable Tf -width 8
      grid $w.data.tab.lt $w.data.tab.vt -sticky w
      frame $w.data.tab.hsep -relief groove -borderwidth 1 -height 2
      grid $w.data.tab.hsep -columnspan 2 -sticky we -pady 2

      foreach n $pars(plot_names) {
        label $w.data.tab.l$n -text "$n:" 
        label $w.data.tab.v$n -fg darkgreen -font {-size 12} -textvariable Df($n) -width 10
        grid $w.data.tab.l$n $w.data.tab.v$n -sticky w
      }
      pack $w.data.tab -side top -expand 1 -fill x
      set top 0
    }
    frames_top {
      labelframe $w.data.lt -text $pars(time_title)
      label $w.data.lt.v -fg darkgreen -font {-size 12} -textvariable Tf -width 8
      pack $w.data.lt.v
      pack $w.data.lt -side left
      foreach n $pars(plot_names) {
        labelframe $w.data.l$n -text "$n:"
        label $w.data.l$n.v -fg darkgreen -font {-size 12} -textvariable Df($n)
        pack $w.data.l$n.v
        pack $w.data.l$n -side left
      }
    }
    frames_left {
      labelframe $w.data.lt -text $pars(time_title)
      label $w.data.lt.v -fg darkgreen -font {-size 12} -textvariable Tf -width 8
      pack $w.data.lt.v
      pack $w.data.lt -side top
      foreach n $pars(plot_names) {
        labelframe $w.data.l$n -text "$n:"
        label $w.data.l$n.v -fg darkgreen -font {-size 12} -textvariable Df($n)
        pack $w.data.l$n.v
        pack $w.data.l$n -side top
      }
      set top 0
    }
    none {}
    default {error "unknown print_value setting"}
  }

  if {$pars(db_dev) != {} && $pars(savebtn)} {
    set ww $w.data.save
    checkbutton $ww -text "save to DB" -selectcolor "red" -bd 1 -relief raised\
      -variable pars(save) -command "set_checkbox_color $ww"
    pack $ww -side [expr {$top? "right":"bottom"}]
    set_checkbox_color $ww
  }

  set Tf [clock format [clock seconds] -format $pars(tfmt)]

  TimePlot time_plot $w.tplot\
   -ncols      $pars(plot_ncols)\
   -maxt       $pars(plot_maxt)\
   -colors     $pars(plot_colors)\
   -titles     $pars(plot_titles)\
   -names      $pars(plot_names)\
   -hides      $pars(plot_hides)\
   -logs       $pars(plot_logs)\
   -symbols    $pars(plot_symbols)\
   -ssizes     $pars(plot_ssizes)\
   -fmts       $pars(plot_fmts)\
   -plots_x    $pars(plots_x)\
   -plots_y    $pars(plots_y)\
   -zstyles    $pars(plots_zst)\
   -use_comm   $pars(plot_comm)\
   -use_marker $pars(plot_marker)

  if {$top} {
    grid $w.data -sticky we
    grid $w.tplot -sticky wens
    grid columnconfigure $w 0 -weight 1
    grid rowconfigure    $w 1 -weight 1
  } else {
    grid $w.data -column 0 -row 0 -sticky n
    grid $w.tplot -column 1 -row 0 -sticky wens
    grid rowconfigure $w 0 -weight 1
    grid columnconfigure $w 1 -weight 1
  }
}

#########################
proc set_checkbox_color {cb} {
  global pars
  set v [set [$cb cget -variable]]
  $cb configure -selectcolor [expr $v?"green":"red"]
}

##########################################################################
##########################################################################
## create the monitor class
Monitor m .m -name $pars(name) -period $pars(period) -onoff $pars(onoff)\
  -func_start func_start -func_stop func_stop\
  -func_meas func_meas -func_mkint func_mkint
pack .m -expand 1 -fill both
wm protocol . WM_DELETE_WINDOW { m do_exit }
