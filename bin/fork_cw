#!/usr/bin/wish

# New inrterface for CW measurements of tuning forks, vibrating wires and similar
# resonators.

# Result database:
# - drive [generator setting]
# - 

package require DeviceRole
package require Exp;  # timeplot, monitor

##########################################################################
## Read parameters from configuration file.
## Devault values can be used for testing, without any devices.

set default_pars {
  name         {fork_cw}  {program name}
  lockin_dev   {TEST}     {lock-in device}
  lockin_pars  {TEST}     {lock-in device parameters}
  gen_dev      {TEST}     {generator device}
  db_dev       {}         {database device}
  res_db       {}         {fit result database}
  sweep_db     {}         {sweep database (record all measured points: T, F,X,Y)}
  pars_db      {}         {sweep parameters database (record sweep parameters: T0, dT, vmin, vmax, npts, dt, dtf, dir, volt, ph)}
  limit_fmin   {0}        {sweep low limit}
  limit_fmax   {inf}      {sweep high limit}
  fmin         {600}      {starting value for sweep low end}
  fmax         {1500}     {starting value for sweep high end}
  npts         {101}      {starting value for sweep number of points}
  dt           {0.1}      {starting value for measurement period}
  dtf          {1}        {starting value for first point delay}
  mode         {Both}     {starting value for sweeping mode}
  swap_xy      {0}        {swap x and y values (do it if fit gives negative width)}
  error_limit  {0.1}      {skip fit result if RMS point deviation divided by amplitude > error_limit}
  tfmt         {%H:%M:%S} {time format string for the interface}
  amp_fmt      {%.3e}     {amp format string for the interface}
  fre_fmt      {%.3f}     {fre format string for the interface}
  wid_fmt      {%.3f}     {wid format string for the interface}
  drv_fmt      {%.3f}     {drive format string for adjustments}
  ph_fmt       {%.1f}     {phase format string for the interface}
  vertical     0          {vertical design of the intereface}
  geometry     {}         {set initial window geometry}
  plot_maxt    {600}      {timeplot span}
  lin_offs     {0}        {Fit with constant/linear offset, 0|1}
  adj_freq     {0}        {adjust central frequency, 0|1}
  adj_fspan    {0}        {adjust frequency span, 0|1}
  adj_fmin     {0}        {min frequency limit for adjustment}
  adj_fmax     {10000}    {max frequency limit for adjustment}
  adj_drive    {0}        {adjust drive, 0|1}
  adj_dmin     {0.02}     {min limit for drive adjustment}
  adj_dmax     {20.0}     {max limit for drive adjustment}
  adj_time     {0}        {adjust timings, 0|1}
  adj_tmin     {0.5}      {min limit for time adjustment}
  adj_tmax     {20.0}     {max limit for time adjustment}
  adj_phase    {0}        {adjust phase, 0|1}
  fspan_size   {6}        {frequency span / width}
  amp_target   {1}        {amplitude target}
  meas_mode    {sweeps}   {sweeps/track}
  track_period {0.5}      {track period, s} 
  track_del    {10}       {initial delay for track mode, s}
  track_adjf   {1}        {adjust frequency in tracking mode 0..1}
  track_adja   {0}        {adjust amplitude in tracking mode 0|1}
  bg6x         {}         {bg parameters for x}
  bg6y         {}         {bg parameters for y}
}

# Background data
# Fx(x) = (a1 + b1*x + c1*x**2 + d1*x**3)/((x**2-f1**2)**2 + (g1*x)**2)
# Fy(x) = (a2 + b2*x + c2*x**2 + d2*x**3)/((x**2-f1**2)**2 + (g1*x)**2)
# bg6x: [a1,b1,c1,d1,f1,g1]
# bg6y: [a2,b2,c2,d2,f2,g2]
# x in kHz, Fx, Fy in uV for 1V drive


if {[llength $argv]>0 } {
  read_conf [lindex $argv 0] pars $default_pars
}\
else {
  foreach {name def title} $default_pars { set pars($name) $def }
}

array unset fitres

tk appname "$pars(name)"

##########################################################################
##########################################################################

# last measurel values
set fre {};
set wid {};
set amp {};
set ph {};

# formatted values
set fre_f {};
set wid_f {};
set amp_f {};
set ph_f {};

# DeviceRole objects
set lockin [DeviceRole $pars(lockin_dev) lock-in {*}$pars(lockin_pars)];
set gen [DeviceRole $pars(gen_dev) ac_source];
if {$pars(db_dev)!={}} { Device $pars(db_dev) }


##########################################################################

# blt vectors for fit result
blt::vector create fitf
blt::vector create fitx
blt::vector create fity
blt::vector create oldf
blt::vector create oldx
blt::vector create oldy
blt::vector create basef
blt::vector create basex
blt::vector create basey

##########################################################################
## functions for the monitor class



##########################################################################
# do adjustments after fitting data
proc adjust_sweep_pars {} {

  global pars
  global fitres

  # Note that sweep_pan set interface values which are validated
  # and applied on the next step.

  if {$pars(adj_freq) || $pars(adj_fspan)} {
    set f1 [sweep_pan get_vmin]
    set f2 [sweep_pan get_vmax]

    if {$pars(adj_freq)} {
      set sh [expr $fitres(f0)-($f1+$f2)/2.0]
      set f1 [expr $f1+$sh]
      set f2 [expr $f2+$sh]
    }

    if {$pars(adj_fspan)} {
      set fcnt [expr ($f1+$f2)/2.0]
      set span [expr abs($fitres(df)*$pars(fspan_size))]
      set f1 [expr $fcnt - $span/2.0]
      set f2 [expr $fcnt + $span/2.0]
    }

    set span [expr abs($f2-$f1)]
    if {$f2 < $f1 } {
      set f1 $f2
      set f2 [expr $f1+$span]
    }
    if {$f1 < $pars(adj_fmin) } {
      set f1 $pars(adj_fmin)
      set f2 [expr $f1+$span]
    }
    if {$f2 > $pars(adj_fmax) } {
      set f2 $pars(adj_fmax)
      set f1 [expr $f2-$span]
    }
    if {$f1 < $pars(adj_fmin) } {
      set f1 $pars(adj_fmin)
    }
    if {$f2 > $pars(adj_fmax) } {
      set f2 $pars(adj_fmax)
    }
    sweep_pan set_vmin [format $pars(fre_fmt) $f1]
    sweep_pan set_vmax [format $pars(fre_fmt) $f2]
  }

  if {$pars(adj_drive)} {
    set v [$::gen get_volt]
    set v [format $pars(drv_fmt) [expr $v*$pars(amp_target)/$fitres(amp)]]
    if {$v > $pars(adj_dmax) } {set v $pars(adj_dmax)}
    if {$v < $pars(adj_dmin) } {set v $pars(adj_dmin)}
    $::gen set_volt $v
  }\
  else {
    set pars(amp_target) [format %.4e $fitres(amp)]
  }

  if {$pars(adj_time)} {
    set dt1  [expr 1.0/abs($fitres(df))]
    set dt2  [$::lockin get_tconst]
    set dt [expr 3.0*max($dt1,$dt2)]
    if {$dt > $pars(adj_tmax) } {set dt $pars(adj_tmax)}
    if {$dt < $pars(adj_tmin) } {set dt $pars(adj_tmin)}
    set dtf [expr {[sweep_pan get_mode] eq "Both"? $dt : 10*$dt}]
    sweep_pan set_dt   [format %.3f $dt]
    sweep_pan set_dtf  [format %.3f $dtf]
  }

  if {$pars(adj_phase)} {
    set p [$::gen get_phase]
    set p [expr {$p + $fitres(ph)}]
    $::gen set_phase [format %.2f $p]
  }
}

# load sweep settings from the database
proc load_pars {} {
  global pars
  if {$pars(db_dev)=={} || $pars(pars_db)=={}} {error "No database"}
  set last [lindex [$pars(db_dev) cmd get $pars(pars_db)] 0]
  sweep_pan set_vmin [lindex $last 2]
  sweep_pan set_vmax [lindex $last 3]
  sweep_pan set_npts [lindex $last 4]
  sweep_pan set_dt   [lindex $last 5]
  sweep_pan set_dtf   [lindex $last 6]
}

# add base to blt vector
proc add_base {vec vecf drive xy} {
  global pars
  if {[llength $pars(bg6$xy)] == 6} {
    set A [lindex $pars(bg6$xy) 0]
    set B [lindex $pars(bg6$xy) 1]
    set C [lindex $pars(bg6$xy) 2]
    set D [lindex $pars(bg6$xy) 3]
    set F [lindex $pars(bg6$xy) 4]
    set G [lindex $pars(bg6$xy) 5]
    $vec expr {$vec + $drive*1e-6*($A+$B*$vecf*1e-3+$C*$vecf^2*1e-6+$D*$vecf^3*1e-9)/(($vecf^2*1e-6-$F^2)^2 + ($G*$vecf*1e-3)^2)}
  }
}

# same for f,x,y value
proc get_base {f drive} {
  global pars
  set ret {}
  foreach xy {x y} {
    if {[llength $pars(bg6$xy)] == 6} {
      set A [lindex $pars(bg6$xy) 0]
      set B [lindex $pars(bg6$xy) 1]
      set C [lindex $pars(bg6$xy) 2]
      set D [lindex $pars(bg6$xy) 3]
      set F [lindex $pars(bg6$xy) 4]
      set G [lindex $pars(bg6$xy) 5]
      lappend ret [expr {$drive*1e-6*($A+$B*$f*1e-3+$C*$f**2*1e-6+$D*$f**3*1e-9)/(($f**2*1e-6-$F**2)**2 + ($G*$f*1e-3)**2)}]
    } else {
      lappend ret 0
    }
  }
  return $ret
}


# get sweep data, do fit, put values to databases.
proc process_sweep_data {} {

  global pars
  #puts "stop sweep"

  # get data from timeplot (BLT-vectors):
  set tv [tplot_sweep get_tvec]
  set fv [tplot_sweep get_dvec 0]
  set xv [tplot_sweep get_dvec 1]
  set yv [tplot_sweep get_dvec 2]
  set drive [$::gen get_volt]
  set phase [$::gen get_phase]

  # put sweep data in the database
  if {$pars(db_dev) != {} && $pars(sweep_db) != {}} {
    for {set i 0} {$i < [$tv length]} {incr i} {
      $pars(db_dev) cmd put $pars(sweep_db) [$tv index $i] [$fv index $i] [$xv index $i] [$yv index $i]
    }
  }

  # put sweep parameters in the database
  if {$pars(db_dev) != {} && $pars(pars_db) != {}} {
    set t0 [$tv index 0]
    set dt [expr [$tv index end] - [$tv index 0]]
    $pars(db_dev) cmd put $pars(pars_db) $t0 $dt\
      [sweep_pan get_vmin] [sweep_pan get_vmax] [sweep_pan get_npts]\
      [sweep_pan get_dt] [sweep_pan get_dtf] [sweep_pan get_dir]\
      $drive $phase
  }

  ##

  # baseline
  basef expr $fv
  basex expr basef*0
  basey expr basef*0
  add_base basex basef $drive x
  add_base basey basef $drive y

  # do fit
  set npars [expr {$pars(lin_offs)? "--pars 8":"--pars 6"}]
  set conn [open "| fit_res $npars" RDWR]
  fconfigure $conn -blocking true -buffering line
  for {set i 0} {$i < [$tv length]} {incr i} {
    set xx [expr {[$xv index $i] - [basex index $i]}]
    set yy [expr {[$yv index $i] - [basey index $i]}]
    puts $conn "[$tv index $i] [$fv index $i] $xx $yy"
  }
  close $conn write
  set res [gets $conn]
  close $conn

  # result, 14 values:
  global fitres
  array unset fitres
  foreach n {T err A Ae B Be C Ce D De f0 f0e df dfe E Ee F Fe} v $res {
    if {$v == {}} {set v 0}
    set fitres($n) $v
  }
  set fitres(amp) [expr {abs(hypot($fitres(C),$fitres(D))/$fitres(f0)/$fitres(df))}]
  set fitres(ph)  [expr {180/3.1415926*atan2($fitres(C),$fitres(D))}]
  set fitres(drive) $drive

  # format values for interface
  global fre_f wid_f amp_f ph_f
  set fre_f [format $pars(fre_fmt) $fitres(f0)]
  set wid_f [format $pars(wid_fmt) $fitres(df)]
  set amp_f [format $pars(amp_fmt) $fitres(amp)]
  set ph_f  [format $pars(ph_fmt)  $fitres(ph)]

  # update plot
  set G [tplot_sweep get_graph]

  # delete previous fits
  if {[$G element names fitx] != {}} {$G element delete fitx}
  if {[$G element names fity] != {}} {$G element delete fity}
  if {[$G element names oldx] != {}} {$G element delete oldx}
  if {[$G element names oldy] != {}} {$G element delete oldy}
  if {[$G element names basex] != {}} {$G element delete basex}
  if {[$G element names basey] != {}} {$G element delete basey}

  # add new fits
  set f1 [$fv index 0]
  set f2 [$fv index end]
  fitf seq $f1 $f2 [expr ($f2-$f1)/1024]
  fitx expr {$fitres(A) + ($fitres(C)*($fitres(f0)^2-fitf^2)+$fitres(D)*(fitf*$fitres(df)))/(($fitres(f0)^2-fitf^2)^2 + (fitf*$fitres(df))^2) + $fitres(E)*(fitf-$fitres(f0))}
  fity expr {$fitres(B) + ($fitres(D)*($fitres(f0)^2-fitf^2)-$fitres(C)*(fitf*$fitres(df)))/(($fitres(f0)^2-fitf^2)^2 + (fitf*$fitres(df))^2) + $fitres(F)*(fitf-$fitres(f0))}

  add_base fitx fitf $drive x
  add_base fity fitf $drive y

  $G element create fitx -outline black -mapx xF -mapy y\
     -xdata fitf -ydata fitx -symbol {}
  $G element create fity -outline black -mapx xF -mapy y\
     -xdata fitf -ydata fity -symbol {}

  # add baseline
  if {[llength $pars(bg6x)] == 6} {
    $G element create basex -color red -mapx xF -mapy y\
     -xdata basef -ydata basex -symbol {}
  }
  if {[llength $pars(bg6y)] == 6} {
    $G element create basey -color blue -mapx xF -mapy y\
       -xdata basef -ydata basey -symbol {}
  }

  # add new data
  oldf expr $fv
  oldx expr $xv
  oldy expr $yv
  $G element create oldx -color #FF8080 -pixel 1.5 -mapx xF -mapy y\
     -xdata oldf -ydata oldx -symbol circle
  $G element create oldy -color #8080FF -pixel 1.5 -mapx xF -mapy y\
     -xdata oldf -ydata oldy -symbol circle

  # skip bad fits
  if {$fitres(err)/$fitres(amp) > $pars(error_limit)} {error "Bad fit: [expr $fitres(err)/$fitres(amp)]"}

  # values for result time plot
  tplot_res add_data [list $fitres(T) $fitres(df) $fitres(f0) $fitres(amp)]

  # put values into database
  if {$pars(db_dev) != {} && $pars(res_db) != {}} {
    $pars(db_dev) cmd put $pars(res_db) $fitres(T) $drive [lrange $res 1 end]
  }

  # Adjust sweep parameters.
  adjust_sweep_pars
}

##########################################################################
# This function is executed in the beginning of each step.
# Here we get new frequncy and delay from sweeper and change
# generator frequency.
proc func_meas {} {
  global pars


  sweep_pan do_step

  if {$pars(meas_mode) eq "track"} { return }

  # set generator panel to readonly state when sweeper is active
  #$::gen readonly [sweep_pan is_on]

  # set generator frequency
  if {[sweep_pan is_on] } {
    $::gen set_freq [sweep_pan get_val]
  }

  # set monitor period
  mon set_period [sweep_pan get_delay]
}

##########################################################################
# This function is executed after the delay, just before
# the next step. Here we measure the new value and collect data.
proc func_meas_e {} {
  global pars
  global fitres


  ####################
  if {$pars(meas_mode) eq "sweep"} {
    if {[sweep_pan is_first]} { tplot_sweep clear }
    if {[sweep_pan is_cancelled]} {return}
  }

  ####################
  # do the measurement
  set t     [expr [clock microsecond]/1e6]
  set f     [$::gen get_freq]
  set drive [$::gen get_volt]

  set v [$::lockin get]
  if {$pars(swap_xy)} {
    set x [lindex $v 1]
    set y [lindex $v 0]
  } else {
    set x [lindex $v 0]
    set y [lindex $v 1]
  }


  if {$pars(lockin_dev) eq "TEST"} {
    set f0 1024
    set df 64
    set F [$::gen get_volt]
    set N 1e-7
    set L 1e-5
    set OffX [expr {$F/($f*$df)*(0.1 + ($f-$f0)/$f0*0.05)}]
    set OffY [expr {$F/($f*$df)*(0.2 + ($f-$f0)/$f0*0.02)}]
    # Random number with normal distribution (see Muller_transform):
    set N [expr $N*sqrt(-2.0 * log(rand()))*cos(2*3.1415926*rand())]
    set x [expr {$N + $OffX + $F*($f*$df)/(($f0**2-$f**2)**2 + ($f*$df)**2)}]
    set y [expr {$N + $OffY + $F*($f0**2-$f**2)/(($f0**2-$f**2)**2 + ($f*$df)**2)}]
    if {$x>+$L} {set x +$L}
    if {$x<-$L} {set x -$L}
    if {$y>+$L} {set y +$L}
    if {$y<-$L} {set y -$L}
  }

  if {$pars(meas_mode) eq "track"} {

    # If drive has changed, rescale resonance parameters
    if {$drive != $fitres(drive)} {
      set k [expr {$drive/$fitres(drive)}]
      set fitres(A) [expr {$k*$fitres(A)}]
      set fitres(B) [expr {$k*$fitres(B)}]
      set fitres(C) [expr {$k*$fitres(C)}]
      set fitres(D) [expr {$k*$fitres(D)}]
      set fitres(E) [expr {$k*$fitres(E)}]
      set fitres(F) [expr {$k*$fitres(F)}]
      set fitres(drive) $drive
    }

    # subtract pre-measured baseline and fitted baseline
    set base [get_base $f $drive]
    set x [expr {$x - [lindex $base 0] - $fitres(A) - $fitres(E)*($f-$fitres(f0))}]
    set y [expr {$y - [lindex $base 1] - $fitres(B) - $fitres(F)*($f-$fitres(f0))}]

    # calculate new f0 and df
    # x + iy = (C + iD)/(f0^2 - f^2 + 1i*f*df)

    # f0^2 = f^2 + Re[(C + iD)/(x + iy)] = f^2 + (C*x + D*y)/(x^2 + y^2)
    # df  = Im[(C + iD)/(x + iy)]/f      = 1/f * (D*x - C*y)/(x^2 + y^2)

    # Calculate new freq, width, amplitude
    set f0 [expr {sqrt($f**2 + ($fitres(C)*$x + $fitres(D)*$y)/($x**2+$y**2))}]
    set df [expr {($fitres(D)*$x - $fitres(C)*$y)/($x**2+$y**2)/$f}]
    set amp [expr {abs(hypot($fitres(C),$fitres(D))/$f0/$df)}]
    set ak [expr $amp/$fitres(amp)]

    tplot_res add_data [list $t $df $f0 $amp]

    # adjust frequency-dependent baseline:
    # A + E*(f-f0) = An + E*(f-f0n)
    # B + F*(f-f0) = Bn + F*(f-f0n)
    # An = A + E*(f0n-f0)
    # Bn = B + F*(f0n-f0)
    set fitres(A) [expr {$fitres(A) + $fitres(E)*($f0-$fitres(f0))}]
    set fitres(B) [expr {$fitres(B) + $fitres(F)*($f0-$fitres(f0))}]
    set fitres(f0) $f0
    set fitres(df) $df
    set fitres(f0e) 0
    set fitres(dfe) 0
    set fitres(amp) $amp

    # format values for interface
    global fre_f wid_f amp_f ph_f
    set fre_f [format $pars(fre_fmt) $fitres(f0)]
    set wid_f [format $pars(wid_fmt) $fitres(df)]
    set amp_f [format $pars(amp_fmt) $fitres(amp)]
    set ph_f  [format $pars(ph_fmt)  $fitres(ph)]

    # put values into database
    if {$pars(db_dev) != {} && $pars(res_db) != {}} {
      set res [list $t $drive]
      foreach n {err A Ae B Be C Ce D De f0 f0e df dfe E Ee F Fe} {
        lappend res $fitres($n)
      }
      $pars(db_dev) cmd put $pars(res_db) {*}$res
    }

    # put sweep data in the database
    if {$pars(db_dev) != {} && $pars(sweep_db) != {}} {
      $pars(db_dev) cmd put $pars(sweep_db) $t $f $x $y
    }

    # adjust generator frequency
    if {$pars(track_adjf)>0} {
      set k  $pars(track_adjf)
      if ($k<0) {set k 0}
      if ($k>1) {set k 1}
      set fa [expr $f0*$k + $f*(1-$k)]
      $::gen set_freq $fa
    }

    # adjust drive
    if {$pars(track_adja)} {
      $::gen set_volt [expr $drive * $pars(amp_target)/$amp]
    }

  }\
  else {
    if {[sweep_pan is_on]} { tplot_sweep add_data [list $t $f $x $y] }
    if {[sweep_pan is_last] } { process_sweep_data }
  }
}

######################################################################
### GUI
# top frame with measurement results
proc mk_frame_top {w} {
  frame $w

  labelframe $w.fre -text {Frequency [Hz]}
  label $w.fre.val -textvariable fre_f -font {-size 15} -text 0
  pack $w.fre.val

  labelframe $w.wid -text {Width [Hz]}
  label $w.wid.val -textvariable wid_f  -font {-size 15} -text 0
  pack $w.wid.val

  labelframe $w.amp -text {Amplitude [Vrms]}
  label $w.amp.val -textvariable amp_f  -font {-size 15} -text 0
  pack $w.amp.val

  labelframe $w.ph -text {Phase [deg]}
  label $w.ph.val -textvariable ph_f  -font {-size 15} -text 0
  pack $w.ph.val

  pack $w.fre $w.wid $w.amp $w.ph -side left -fill x -expand 1
}

# measurement type frame (sweeps/offsets/track tabset)
proc mk_frame_meas_tabs {w} {
  global pars

  blt::tabset $w

  set f $w.sweeps
  frame $f
  $w insert end sweeps -window $f\
     -anchor n -text "Sweeps" -fill both -padx 3 -pady 3

  # sweep panel
  widget_sweep sweep_pan $f.sw\
    -title "Sweeps:"\
    -vmin_label "F1" -vmax_label "F2"\
    -vmin $pars(fmin) -vmax $pars(fmax)\
    -limit_min $pars(limit_fmin)\
    -limit_max $pars(limit_fmax)\
    -npts $pars(npts)\
    -mode $pars(mode)\
    -dt   $pars(dt)\
    -dtf  $pars(dtf)\
    -cmd_start on_track_stop\
    -cmd_stop  on_track_stop

  pack $f.sw -expand 0 -fill x -anchor ne
  widget_bg $f.sw #E0F0F0

  # adjust panel
  labelframe $f.adj -text "Fit and Adjust:" -font {-weight bold -size 10}
  checkbutton $f.adj.lof -text "Use linear offsets in the fit" -variable pars(lin_offs)
  checkbutton $f.adj.f0  -text "Central frequency" -variable pars(adj_freq)
  checkbutton $f.adj.df  -text "Frequency span" -variable pars(adj_fspan)
  checkbutton $f.adj.drv -text "Target amplitude:" -variable pars(adj_drive)
  checkbutton $f.adj.tt  -text "Time step" -variable pars(adj_time)
  checkbutton $f.adj.ph  -text "Phase" -variable pars(adj_phase)
  entry $f.adj.am_v -width 12 -textvariable pars(amp_target)
  button $f.adj.load -text "Load from DB" -command load_pars

  grid $f.adj.lof -sticky nw -columnspan 2
  grid $f.adj.f0 $f.adj.df  -sticky nw
  grid $f.adj.drv $f.adj.am_v -sticky nw
  grid $f.adj.tt $f.adj.ph  -sticky nw
  grid $f.adj.load -sticky nw -padx 2 -pady 2

  pack $f.adj -expand 0 -fill x -anchor ne
  widget_bg $f.adj #E0E0F0

  ###########
  ## adjustment parameters

  set f $w.adjpar
  frame $f
  $w insert end adjpar -window $f\
     -anchor n -text "Adj.Pars" -fill both -padx 3 -pady 3

  label $f.fspan_l -text "Span size (in line widths):"
  entry $f.fspan_v -width 4 -textvariable pars(fspan_size)
  grid $f.fspan_l $f.fspan_v -sticky nw

  label $f.flim_l -text "Frequency limits:"
  entry $f.fmin -width 10 -textvariable pars(adj_fmin)
  entry $f.fmax -width 10 -textvariable pars(adj_fmax)
  grid $f.flim_l -sticky nw -columnspan 2
  grid $f.fmin $f.fmax -sticky nw

  label $f.dlim_l -text "Drive limits:"
  entry $f.dmin -width 10 -textvariable pars(adj_dmin)
  entry $f.dmax -width 10 -textvariable pars(adj_dmax)
  grid $f.dlim_l -sticky nw -columnspan 2
  grid $f.dmin $f.dmax -sticky nw

  label $f.tlim_l -text "Time step limits:"
  entry $f.tmin -width 10 -textvariable pars(adj_tmin)
  entry $f.tmax -width 10 -textvariable pars(adj_tmax)
  grid $f.tlim_l -sticky nw -columnspan 2
  grid $f.tmin $f.tmax -sticky nw

  ###########
  ## offsets measurements
  set f $w.conf_offs
  frame $f
  $w insert end offs -window $f\
     -anchor n -text "Offsets" -fill both -padx 3 -pady 3

  labelframe $f.f1 -text "Generator AC offset"
  pack $f.f1 -expand 0 -fill x -anchor ne

  button $f.f1.meas  -command set_ac_shift -text "Measure and set"
  button $f.f1.reset -command clear_ac_shift -text "Reset to zero"
  pack $f.f1.meas -expand 0 -fill x -anchor ne
  pack $f.f1.reset -expand 0 -fill x -anchor ne


}


# Build GUI frame in <root>
proc func_mkint {w} {
  global fitres pars

  ############################
  # top frame with measurement results
  mk_frame_top $w.res
  pack $w.res -fill x -expand 0

  ############################
  # tabs
  blt::tabset $w.tabs
  pack $w.tabs -fill both -expand 1

  ############################
  ### measurement frame
  set f_meas $w.tabs.meas
  frame $f_meas
  $w.tabs insert end meas -window $f_meas\
     -anchor n -text "Measurement" -fill both -padx 3 -pady 3

  ####
  # configuration frame
  set f_conf $f_meas.conf
  frame $f_conf

  mk_frame_meas_tabs $f_conf.meas_tabs
  pack $f_conf.meas_tabs -expand 0 -fill x -anchor ne

  # lock-in panel
  $::lockin make_widget $f_conf.lockin\
    -title "Lock-in:" -bar_w 256
  pack $f_conf.lockin -expand 0 -fill x -anchor ne
  widget_bg $f_conf.lockin #F0E0F0

  # generator panel
  $::gen make_widget $f_conf.gen\
    -title "Generator:" -show_ac_shift 0
  pack $f_conf.gen -expand 0 -fill x -anchor ne
  widget_bg $f_conf.gen #F0F0E0


  ####
  # sweep timeplot (4 columns: f, x, y, a)
  TimePlot tplot_sweep $f_meas.tplot\
   -ncols      3\
   -maxt       3600\
   -colors     {black red blue}\
   -names      {F X Y}\
   -titles     {F X Y}\
   -symbols    {circle circle circle circle}\
   -ssizes     {}\
   -fmts       %.2f\
   -plots_x     {F}\
   -plots_y     {{X Y}}\
   -zstyles    xy

  if {$pars(vertical)} {
    grid $f_meas.tplot  -sticky wens
    grid $f_conf -sticky ew
    grid rowconfigure $f_meas 1 -weight 1
    grid columnconfigure $f_meas 0 -weight 1
  }\
  else {
    grid $f_conf $f_meas.tplot  -sticky wens
    grid rowconfigure $f_meas 0 -weight 1
    grid columnconfigure $f_meas 1 -weight 1
  }

  ############################
  ### Timeplot/Track
  set f_res $w.tabs.res
  frame $f_res
  $w.tabs insert end res -window $f_res\
     -anchor n -text "Res/Track" -fill both -padx 3 -pady 3

  TimePlot tplot_res $f_res.tplot\
   -ncols      3\
   -maxt       $pars(plot_maxt)\
   -colors     {}\
   -names      {W F A}\
   -titles     {W F A}\
   -symbols    {circle circle circle}\
   -ssizes     {}\
   -fmts       {$pars(wid_fmt) $pars(fre_fmt) $pars(amp_fmt)}\

  pack $f_res.tplot -expand 1 -fill both -anchor ne
  label $f_res.l -text "Track mode: "
  button $f_res.start -command on_track_start -text "Start"
  button $f_res.stop  -command on_track_stop  -text "Stop"
  label $f_res.ffl -text "AdjFre:"
  entry  $f_res.ff -textvariable pars(track_adjf) -width 4
  checkbutton $f_res.fa -text "AdjAmp" -variable pars(track_adja)
  pack $f_res.l $f_res.start $f_res.stop $f_res.ffl $f_res.ff $f_res.fa -side left -expand 0 -anchor nw
}

############################
# Track start/stop buttons
proc on_track_start {} {
  global fitres pars
  if {$pars(meas_mode) eq "track"} return
  if {![array exists fitres]} { error "No measured resonance available" }

  sweep_pan stop
  sweep_pan do_step
  mon set_period $pars(track_period)
  $::gen set_freq $fitres(f0)
  after [expr {int($pars(track_del)*1000)}]
  set pars(meas_mode) "track"
}

proc on_track_stop {} {
  global pars
  if {$pars(meas_mode) eq "sweep"} return
  set pars(meas_mode) "sweep"
}



proc set_ac_shift {} {
  $::gen set_ac_shift 0
  set ph [$::gen get_phase]
  set v0 [$::gen get_volt]
  set dt [expr round(5*[$::lockin get_tconst]*1000)]

  after $dt
  set XY1 [$::lockin get]
  $::gen set_phase [expr $ph+180]

  after $dt
  set XY2 [$::lockin get]

  set x1 [lindex $XY1 0]
  set y1 [lindex $XY1 1]
  set x2 [lindex $XY2 0]
  set y2 [lindex $XY2 1]

  # abs(V2-V1), abs(V2+V1)
  set Am [expr {sqrt(($x2-$x1)**2 + ($y2-$y1)**2)}]
  set Ap [expr {sqrt(($x2+$x1)**2 + ($y2+$y1)**2)}]

  # arg(V2-V1), arg(V2+V1)
  set Pm [expr {180/3.148926*atan2($y2-$y1, $x2-$x1)}]
  set Pp [expr {180/3.148926*atan2($y2+$y1, $x2+$x1)}]

  $::gen set_phase [expr $ph+$Pm-$Pp]
  $::gen set_ac_shift [format %.4f [expr $v0*$Ap/$Am]]
}

proc clear_ac_shift {} {
  $::gen set_ac_shift 0
}

##########################################################################
##########################################################################
## create the monitor class
Monitor mon .m -name $pars(name) -period 1 -onoff 1\
  -func_start {} -func_stop {}\
  -func_meas func_meas -func_meas_e func_meas_e -func_mkint func_mkint\
  -show_ctl 0 -show_title 1 -verb 0 -wait_meas 0

pack .m -expand 1 -fill both
wm protocol . WM_DELETE_WINDOW { mon do_exit }
if {$pars(geometry) != {}} {wm geometry . $pars(geometry)}
