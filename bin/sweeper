#!/usr/bin/wish

## Interface for current sweeper

package require Device 1.2
package require xBlt 3
package require Exp

######################################################
### Read parameters from configuration file

set default_pars {
  name        {Default sweeper} {program title}
  ps_dev      TEST  {1st power supply device}
  ps_dev2     {}    {2nd power supply device}
  antipar      0    {anti-parallel connection}
  gauge_dev   {}    {measure device}
  ovp           5   {overvoltage protection, V}
  ramp_tstep  0.2   {ramping time step}
  idle_tstep  0.5   {idle time step}
  c_units      A    {current units: A, mA, uA}
  r_units      A/s  {rate units, A/s, mA/s, uA/s, A/min, mA/min, uA/min, A/h, mA/h, uA/h}
  maxI          2   {max current, c_units}
  minI          0   {min current, c_units}
  max_rate     0.01 {max rate, r_units}
  def_rate    0.001 {default rate, r_units}
  gain         1.0  {gain, ratio of solenoid and device currents (if some divider is used)}
  skip         0    {do not write a point if current was not set}
  db           {}   {db device}
  db_val       {}   {database for sweeper values}
  db_ann       {}   {database for sweeper comments}
  db_comm      {}   {database for high-level comments}
  interface_type {grad}   {interface control type: nmr, grad, hs}
  plot_ncols   2    {number of columns in the plot}
  plot_maxt    600  {max time span in the plot}
  plot_maxn    0    {max number of points in the plot}
  plot_names   {Imeas Iset V R}   {column names}
  plot_titles  {}      {column titles}
  plot_colors  {}      {column colors}
  plot_hides   {}      {column hides}
  plot_logs    {}      {column log scales}
  plot_symbols {}      {symbols}
  plot_ssizes  {}      {symbol sizes}
  plot_fmts    {}      {column format settings}
  plot_comm    1       {use comment in the plot}
  plot_marker  0       {use marker in the plot}
  plots_x   {time Iset} {x data for plots}
  plots_y   {{} {}}     {y data for plots}
  plots_zst    {}       {zoom styles for plots}
}

if {[llength $argv]>0 } {
  read_conf [lindex $argv 0] pars $default_pars
}\
else {
  foreach {name def title} $default_pars { set pars($name) $def }
}

# Set current multiplier
set c_k {}
if {$pars(c_units)=={A}}      { set c_k 1 }
if {$pars(c_units)=={mA}}     { set c_k 1e-3 }
if {$pars(c_units)=={uI}}     { set c_k 1e-6 }
if {$c_k == {}} {error "unknown current units: $pars(c_units)"}

# Set rate multiplier
set r_k {}
if {$pars(r_units)=={A/s}}    { set r_k 1 }
if {$pars(r_units)=={mA/s}}   { set r_k 1e-3 }
if {$pars(r_units)=={uA/s}}   { set r_k 1e-6 }
if {$pars(r_units)=={A/min}}  { set r_k [expr 1.0/60]}
if {$pars(r_units)=={mA/min}} { set r_k [expr 1e-3/60]}
if {$pars(r_units)=={uA/min}} { set r_k [expr 1e-6/60]}
if {$pars(r_units)=={A/h}}  { set r_k [expr 1.0/3600]}
if {$pars(r_units)=={mA/h}} { set r_k [expr 1e-3/3600]}
if {$pars(r_units)=={uA/h}} { set r_k [expr 1e-6/3600]}
if {$r_k == {}} {error "unknown rate units: $pars(r_units)"}


wm title . "sweeper: $pars(name)"
tk appname "sweeper: $pars(name)"

######################################################
### Create current sweeper

SweepController sweeper\
  -ps_dev1    $pars(ps_dev)\
  -ps_dev2    $pars(ps_dev2)\
  -antipar    $pars(antipar)\
  -gauge      $pars(gauge_dev)\
  -db_dev     $pars(db)\
  -db_val     $pars(db_val)\
  -db_ann     $pars(db_ann)\
  -max_volt   $pars(ovp)\
  -max_rate   [expr $pars(max_rate)*$r_k]\
  -gain       $pars(gain)\
  -ramp_tstep $pars(ramp_tstep)\
  -idle_tstep $pars(idle_tstep)\
  -on_new_val on_new_val\
  -on_new_com on_new_com

##########################################################
## interface for external use

set current 0;      ## current value shown in the interface
set resistance 0;   ## resistance value in the interface
set dev_status {};  ## device status string (CC, OV etc)

set state 0;      ## does sweeper work?
set rate  $pars(def_rate)
set dest1 $pars(minI)
set dest2 $pars(maxI)

# set/get sweep limits (A/mA/uA)
proc set_limits {v1 v2} {
  global pars c_k
  if {$v1 < $pars(minI)} {set v1 $pars(minI)}
  if {$v1 > $pars(maxI)} {set v1 $pars(maxI)}
  if {$v2 < $pars(minI)} {set v2 $pars(minI)}
  if {$v2 > $pars(maxI)} {set v2 $pars(maxI)}
  sweeper set_limits [expr $v1*$c_k] [expr $v2*$c_k]
  set l [sweeper get_limits]
  set ::dest1 [expr [lindex $l 0]/$c_k]
  set ::dest2 [expr [lindex $l 1]/$c_k]
}
proc get_limits {} {
   set l [sweeper get_limits]
   set v1 [expr [lindex $l 0]/$c_k]
   set v2 [expr [lindex $l 1]/$c_k]
   return [list $v1 $v2]
}

proc set_ulimit {v} { set_limits $::dest1 $v }
proc set_llimit {v} { set_limits $v $::dest2 }
proc get_dir  {}   { return [sweeper get_dir] }
proc get_rate {}   { return [expr [sweeper get_rate]/$::r_k] }

proc sweep {dir wait} {
  global r_k
  if {$::state == 0} {return}
  set_limits $::dest1 $::dest2
  sweeper go [expr $r_k*$::rate] $dir $wait
}

proc sweep_to2 {} {
  global r_k
  if {$::state == 0} {return}
  set_limits $::dest2 $::dest2
  sweeper go [expr $r_k*$::rate] 1 1
}

proc stop {} {
  if {$::state == 0} {return}
  sweeper stop
}
proc go_back {} {
  if {$::state == 0} {return}
  sweeper go_back
}
proc do_reset {} {
  if {$::state == 0} {return}
  sweeper reset
}

proc do_onoff {state} {
  if {$state == 0} { sweeper turn_off }\
  else { sweeper turn_on }
  enable $state
  set ::state $state
}

##########################################################
## a few things for the interface
set control_widgets {}; # list of widgets to be enabled/disabled

proc enable {v} {
  foreach w $::control_widgets {
    foreach ch [winfo children $w] {
      $ch configure -state [expr {$v?{normal}:{disabled}}]
    }
  }
}

set plot_widget {}

##########################################################

proc on_new_com {t com} {
  time_plot add_comment $t $com
  # put a high-level comment after finishing sweep:
  if {[regexp {finished} $com] } {
    if {$::pars(db)!={} && $::pars(db_comm)!={}} {
      Device $::pars(db)
      $::pars(db) cmd put $::pars(db_comm) now "$::pars(name) -> $::current A"
      itcl::delete object $::pars(db)
    }
  }
  return
}

## update values command
proc on_new_val {t cm cs vm {m 0}} {
  global pars c_k
  set ::current    [format "%.3f" [expr $cm/$c_k]]
  set ::resistance [format "%.3f" [expr { $cm>0? $vm/$cm:0} ]]
  set ::dev_status [sweeper get_stat]
  time_plot add_data [list $t [expr $cm/$c_k] [expr $cs/$c_k] $vm $::resistance {*}$m]
  return
}

##########################################################
## make interface

## "NMR" version
proc make_control {root} {
  labelframe $root -padx 5 -pady 5

  frame $root.m;  # measure frame
  label $root.m.vI -font {-size 14 -weight bold} -textvariable ::current
  label $root.m.uI -text " $::pars(c_units), " -font {-size 12}
  label $root.m.vR -font {-size 14 -weight bold} -textvariable ::resistance
  label $root.m.uR -text " Ohm " -font {-size 12}
  label $root.m.st -font {-size 14 -weight bold} -fg darkgreen -textvariable ::dev_status
  grid $root.m.vI $root.m.uI\
       $root.m.vR $root.m.uR $root.m.st -sticky w
  pack $root.m -fill x


  if {$::pars(interface_type) == {nmr}} {
    frame $root.g1;  # go frame
    label $root.g1.ldest1 -text "destination 1: " -padx 2 -pady 2
    entry $root.g1.dest1  -width 10 -textvariable ::dest1
    label $root.g1.udest1 -text "($::pars(c_units)), "
    label $root.g1.ldest2 -text "destination 2: " -padx 2 -pady 2
    entry $root.g1.dest2  -width 10 -textvariable ::dest2
    label $root.g1.udest2 -text "($::pars(c_units)), "
    label $root.g1.lrate -text "rate: " -padx 2 -pady 2
    entry $root.g1.rate -width 6 -textvariable ::rate
    label $root.g1.urate -text "($::pars(r_units)) "
    grid $root.g1.ldest1 $root.g1.dest1 $root.g1.udest1\
         $root.g1.ldest2 $root.g1.dest2 $root.g1.udest2\
         $root.g1.lrate $root.g1.rate $root.g1.urate\
       -sticky w
    pack $root.g1 -fill x

    frame $root.g2;  # go frame
    button $root.g2.b1   -text "Go down" -padx 10 -pady 3 -command {sweep -1 0}
    button $root.g2.b2   -text "Go up"   -padx 10 -pady 3 -command {sweep +1 0}
    button $root.g2.b3   -text "Go back" -padx 10 -pady 3 -command go_back
    button $root.g2.b4   -text "Stop" -padx 10 -pady 3 -command stop
    grid $root.g2.b1 $root.g2.b2 $root.g2.b3 $root.g2.b4 -sticky we -padx 3

    button $root.g2.b5   -text "To lower limit"   -pady 3 -command {sweep -1 1}
    button $root.g2.b6   -text "To upper limit"   -pady 3 -command {sweep +1 1}
    button $root.g2.b7   -text "To Zero" -pady 3 -command {set_llimit 0; sweep -1 1}
    grid $root.g2.b5 $root.g2.b6 $root.g2.b7 -sticky we -padx 3

    pack $root.g2 -fill x -expand yes

    set ::control_widgets [list $root.m $root.g1 $root.g2]
  }

  if {$::pars(interface_type) == {grad}} {
    frame $root.g1;  # go frame
    label $root.g1.ldest2 -text "destination: " -padx 2 -pady 2
    entry $root.g1.dest2  -width 10 -textvariable ::dest2
    label $root.g1.udest2 -text "($::pars(c_units)), "
    label $root.g1.lrate -text "rate: " -padx 2 -pady 2
    entry $root.g1.rate -width 6 -textvariable ::rate
    label $root.g1.urate -text "($::pars(r_units)) "
    button $root.g1.gu   -text "Go"   -pady 3 -command {sweep_to2}
    button $root.g1.gd   -text "To Zero" -pady 3 -command {set_limits 0 0; sweep_to2}
    button $root.g1.st   -text "Stop" -pady 3 -command stop
    grid $root.g1.ldest2 $root.g1.dest2 $root.g1.udest2\
         $root.g1.lrate $root.g1.rate $root.g1.urate\
         $root.g1.gu $root.g1.st $root.g1.gd\
       -sticky w -padx 3
    pack $root.g1 -fill x
    set ::control_widgets [list $root.m $root.g1]
  }

  if {$::pars(interface_type) == {hs}} {
    frame $root.g2;  # go frame
    button $root.g2.gu   -text "Up"   -padx 10 -pady 3 -command {sweep +1 1}
    button $root.g2.gd   -text "Down" -padx 10 -pady 3 -command {sweep -1 1}
    grid $root.g2.gu $root.g2.gd -sticky we -padx 3
    pack $root.g2 -fill x -expand yes
    set ::control_widgets [list $root.m $root.g2]
  }
  enable 0

  frame $root.b;  # button frame
  checkbutton $root.b.oo -text "on/off" -variable ::state -command {do_onoff $::state}
  grid $root.b.oo -sticky w
  pack $root.b -fill x

}

######################
# program title
frame .n
label .n.name   -text "$pars(name)" -font {-size 20}
pack .n.name -side left -padx 10

if {$pars(gain)!=1} {
  label .n.gain   -text "(gain: $pars(gain))" -font {-size 20}
  pack .n.gain -side left -padx 10
}

pack .n -anchor w

######################
# buttons
make_control .f
pack .f -anchor w -fill x -expand 0

######################
# make graph
TimePlot time_plot .tplot\
   -ncols $pars(plot_ncols)\
   -maxt $pars(plot_maxt)\
   -colors $pars(plot_colors)\
   -titles $pars(plot_titles)\
   -names  $pars(plot_names)\
   -hides    $pars(plot_hides)\
   -logs     $pars(plot_logs)\
   -symbols  $pars(plot_symbols)\
   -ssizes   $pars(plot_ssizes)\
   -fmts     $pars(plot_fmts)\
   -plots_x  $pars(plots_x)\
   -plots_y  $pars(plots_y)\
   -zstyles  $pars(plots_zst)\
   -use_comm   $pars(plot_comm)\
   -use_marker $pars(plot_marker)

pack .tplot -fill both -expand 1

##########################################################

set_limits $dest1 $dest2

